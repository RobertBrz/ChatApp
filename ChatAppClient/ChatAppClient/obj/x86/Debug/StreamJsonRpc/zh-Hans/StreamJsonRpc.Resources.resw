<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TaskWasCancelled" xml:space="preserve">
    <value>任务已取消。</value>
  </data>
  <data name="StreamDisposed" xml:space="preserve">
    <value>已释放流</value>
  </data>
  <data name="UnableToFindMethod" xml:space="preserve">
    <value>找不到 {2} 上的方法“{0}/{1}”，原因如下：{3}</value>
  </data>
  <data name="ResponseIsNotError" xml:space="preserve">
    <value>响应不是错误。</value>
  </data>
  <data name="UnexpectedErrorProcessingJsonRpc" xml:space="preserve">
    <value>处理 JSON-RPC 消息时出现意外错误: {0}</value>
  </data>
  <data name="CancellationTokenMustBeLastParameter" xml:space="preserve">
    <value>CancellationToken 只能用作最后一个参数。</value>
  </data>
  <data name="UnsupportedEventHandlerTypeOnClientProxyInterface" xml:space="preserve">
    <value>“{0}”上不受支持的事件处理程序类型。只支持 EventHandler 和 EventHandler&lt;T&gt;。</value>
  </data>
  <data name="ParameterObjectsNotSupportedInJsonRpc10" xml:space="preserve">
    <value>JSON-RPC 1.0 不支持命名参数(在对象中传递的参数)。请使用位置参数(参数数组)或将协议版本设置为 2.0。</value>
  </data>
  <data name="TargetObjectAndMethodStaticFlagMismatch" xml:space="preserve">
    <value>当且仅当方法不是静态时，才提供目标对象。</value>
  </data>
  <data name="UnrecognizedIncomingJsonRpc" xml:space="preserve">
    <value>传入的 JSON-RPC 消息不符合已识别的模式。</value>
  </data>
  <data name="TextEncoderNotApplicable" xml:space="preserve">
    <value>不支持文本编码，因为格式化程序“{0}”未实现“{1}”。</value>
  </data>
  <data name="ConflictingMethodNameAttribute" xml:space="preserve">
    <value>“{0}”方法的所有重载和重写必须共享 {1}.{2} 的常见值。</value>
  </data>
  <data name="ReadingJsonRpcStreamFailed" xml:space="preserve">
    <value>从流读取 JSON RPC 失败，出现 {0}：{1}</value>
  </data>
  <data name="ConnectionDropped" xml:space="preserve">
    <value>在请求完成之前, 与远程方的 JSON-RPC 连接已丢失。</value>
  </data>
  <data name="DroppingRequestDueToNoTargetObject" xml:space="preserve">
    <value>已获得执行“{0}”的请求，但没有回调对象。删除请求。</value>
  </data>
  <data name="FormatterConfigurationLockedAfterJsonRpcAssigned" xml:space="preserve">
    <value>The configuration is locked because this formatter has already been associated with a JsonRpc instance.</value>
  </data>
  <data name="PositiveIntegerRequired" xml:space="preserve">
    <value>必须提供一个正整数。</value>
  </data>
  <data name="StreamMustBeWriteable" xml:space="preserve">
    <value>流必须可写。</value>
  </data>
  <data name="ResponseUnexpectedFormat" xml:space="preserve">
    <value>Response is in an unexpected format.  Only error and result are supported: {0}</value>
  </data>
  <data name="JsonRpcCannotBeNull" xml:space="preserve">
    <value>JSON RPC 不得为 null。</value>
  </data>
  <data name="BothReadableWritableAreNull" xml:space="preserve">
    <value>可读内容和可写内容均为 null。</value>
  </data>
  <data name="FillBufferFirst" xml:space="preserve">
    <value>缓冲区为空。请先调用异步方法进行填充。</value>
  </data>
  <data name="ReachedEndOfStream" xml:space="preserve">
    <value>已达到流结尾。</value>
  </data>
  <data name="HeaderValueTooLarge" xml:space="preserve">
    <value>邮件标头的大小超出了支持的最大大小。</value>
  </data>
  <data name="FailureDeserializingJsonRpc" xml:space="preserve">
    <value>反序列化传入 JSON RPC“{0}”时失败：{1}</value>
  </data>
  <data name="RpcMethodNameNotFound" xml:space="preserve">
    <value>找不到名为“{0}”的方法。</value>
  </data>
  <data name="SumOfTwoParametersExceedsArrayLength" xml:space="preserve">
    <value>{0} 和 {1} 参数超出了数组的长度。</value>
  </data>
  <data name="UnsupportedPropertiesOnClientProxyInterface" xml:space="preserve">
    <value>服务接口不支持属性。</value>
  </data>
  <data name="NonNegativeIntegerRequired" xml:space="preserve">
    <value>必须提供一个非负整数。</value>
  </data>
  <data name="MethodParametersNotCompatible" xml:space="preserve">
    <value>{0} 参数与请求中提供的参数不兼容。</value>
  </data>
  <data name="MustBeListening" xml:space="preserve">
    <value>必须先开始侦听。</value>
  </data>
  <data name="ParameterNotObject" xml:space="preserve">
    <value>参数不是单对象的形式</value>
  </data>
  <data name="MustNotBeListening" xml:space="preserve">
    <value>侦听开始后，无法完成此操作。</value>
  </data>
  <data name="InvalidAfterListenHasStarted" xml:space="preserve">
    <value>启动消息侦听后不允许此操作。</value>
  </data>
  <data name="HeaderContentLengthNotParseable" xml:space="preserve">
    <value>无法将 Content-Length 标头分析为一个正整数。</value>
  </data>
  <data name="RelayAlreadySet" xml:space="preserve">
    <value>Relay connection has already been established.</value>
  </data>
  <data name="TaskNotCompleted" xml:space="preserve">
    <value>任务未完成。</value>
  </data>
  <data name="MethodHasRefOrOutParameters" xml:space="preserve">
    <value>{0} 具有不受支持的 ref 或 out 参数</value>
  </data>
  <data name="InvalidBeforeListenHasStarted" xml:space="preserve">
    <value>启动消息侦听前不允许此操作。</value>
  </data>
  <data name="NotSupportedWithoutMultiplexingStream" xml:space="preserve">
    <value>Out of band streams/pipes are not supported in this configuration. Have you set a MultiplexingStream on the formatter?</value>
  </data>
  <data name="RequiredArgumentMissing" xml:space="preserve">
    <value>没有为所需参数提供参数。</value>
  </data>
  <data name="ConflictingMethodAttributeValue" xml:space="preserve">
    <value>.NET 方法“{0}”和“{1}”不能映射到同一请求方法名“{2}”。</value>
  </data>
  <data name="StreamMustBeReadable" xml:space="preserve">
    <value>流必须可读。</value>
  </data>
  <data name="ErrorWritingJsonRpcMessage" xml:space="preserve">
    <value>写入 JSON RPC 消息时出错: {0}: {1}</value>
  </data>
  <data name="MarshaledObjectInResponseOrNotificationError" xml:space="preserve">
    <value>This tracked object should not be part of any response or notification.</value>
  </data>
  <data name="MethodParameterCountDoesNotMatch" xml:space="preserve">
    <value>{0} 参数（排除任何 CancellationToken）：{1}，但请求提供 {2}</value>
  </data>
  <data name="UnsupportedJsonRpcProtocolVersion" xml:space="preserve">
    <value>JSON-RPC 协议版本 {0} 不受支持。支持的协议版本为: {1}</value>
  </data>
  <data name="FatalExceptionWasThrown" xml:space="preserve">
    <value>服务器方法 {0} 引发了严重的异常: {1}</value>
  </data>
  <data name="UnexpectedTokenReadingHeader" xml:space="preserve">
    <value>分析标头时出现意外标记“{0}”。</value>
  </data>
  <data name="ConflictMethodSignatureAlreadyRegistered" xml:space="preserve">
    <value>已注册了具有相同名称和等效参数的方法。</value>
  </data>
  <data name="ErrorWritingJsonRpcResult" xml:space="preserve">
    <value>写入 JSON RPC 结果 {0} 时出错：{1}</value>
  </data>
  <data name="ClientProxyTypeArgumentMustBeAnInterface" xml:space="preserve">
    <value>“{0}”不是接口。</value>
  </data>
  <data name="UnsupportedGenericMethodsOnClientProxyInterface" xml:space="preserve">
    <value>不支持泛型方法。</value>
  </data>
  <data name="FindIProgressOfTError" xml:space="preserve">
    <value>Unable to cast given Type to IProgress&lt;T&gt;</value>
  </data>
  <data name="UnsupportedMethodReturnTypeOnClientProxyInterface" xml:space="preserve">
    <value>方法“{0}”具有不支持的返回类型“{1}”。只支持返回任务的方法。</value>
  </data>
</root>